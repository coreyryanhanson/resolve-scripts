"""A module that uses ffmpeg to extract stills based on the csvs generated
by the Resolve script create_subtitle_label_seq_from_clip.py"""

from csv import DictReader
import glob
import os
import subprocess
from typing import Optional

from ..message_handling import MessageHandlingObject


class FfmpegCsvExporter(MessageHandlingObject):
    """Custom class to extract still images according to the timecode listed
    in the csvs generated by create_subtitle_label_seq_from_clip.py.

    Args:
        csv_directory (str): The directory where the timecode csvs are.
        media_directory (str): The directory where the correspoinding video
            clips are.
        output_directory (Optional[str], optional): The directory where the
            files should be saved. If unspecified, it will output to the media
            directory (with a subfolder for every clip). Defaults to None.
    """
    def __init__(self,
                 csv_directory: str,
                 media_directory: str,
                 output_directory: Optional[str] = None,
                 **kwargs
                 ) -> None:
        if kwargs.get("shared_logger", None) is None:
            logger_name = kwargs.pop("logger_name", "ffmpeg_exporter")
        super().__init__(logger_name=logger_name, **kwargs)
        self._csvs = self._get_csv_paths(csv_directory)
        self._input_dir = media_directory
        self._output_dir = output_directory or media_directory
        self.frame_digits = 8
        self.ffmpeg_out_suffix = f"%0{self.frame_digits}d"
        self._output_placeholder = None

    def _get_csv_paths(self, csv_directory: str) -> list[str]:
        return sorted(glob.iglob(os.path.join(csv_directory, "*.csv")))

    def _parse_params(self, row, keys):
        return [row[key] for key in keys]

    def _convert_range_to_int(self, start, end):
        start, end = [int(s) for s in [start, end]]
        if start >= end:
            self._raise(RuntimeError("Start to end has duration of "
                                     f"{end - start}"))
        if start < 0:
            self._raise(RuntimeError("Frame indicators must be positive "
                                     "integers."))
        return start, end

    def _create_media_path(self, filename):
        path = os.path.join(self._input_dir, filename)
        if not os.path.exists(path):
            self._raise(FileNotFoundError(f"{path} does not exist."))
        return path

    def _check_input_path(self, filename, last_filename):
        if filename != last_filename:
            self._raise(RuntimeError("One filename is permitted per csv."))

    def _generate_output_placeholder(self, output_arg):
        old = self.ffmpeg_out_suffix
        new = "{i:0" + str(self.frame_digits) + "d}"
        self._output_placeholder = output_arg.replace(old, new)

    def _generate_ffmpeg_png_path(self, media_fn):
        directory = os.path.splitext(media_fn)[0]
        fn = f"{directory}_{self.ffmpeg_out_suffix}.png"
        directory = os.path.join(self._output_dir, directory)
        os.makedirs(directory, exist_ok=True)
        path = os.path.join(directory, fn)
        self._generate_output_placeholder(path)
        return path

    def _generate_ffmpeg_args(self, input_path, media_fn, start, end):
        return [
            "ffmpeg", "-i", input_path, "-start_number", str(start), "-vf",
            f'select=between(n\\,{start}\\,{end-1}),setpts=PTS-STARTPTS',
            self._generate_ffmpeg_png_path(media_fn)
            ]

    def _create_queues_from_csv(self, csv_path):
        self._print(f"Extracting instructions from {csv_path}")
        keys = ["file", "start", "end"]
        last_frame = 0
        error_count = 0
        last_file = None
        deletion_queue = []
        with open(csv_path, "r") as f:
            reader = DictReader(f)
            for i, row in enumerate(reader):
                try:
                    file, start, end = self._parse_params(row, keys)
                    input_path = self._create_media_path(file)
                    start, end = self._convert_range_to_int(start, end)
                except (KeyError,
                        FileNotFoundError,
                        ValueError,
                        RuntimeError) as e:
                    error_count += 1
                    self._warn(f"Error {error_count} on csv row {i} "
                               f"for {csv_path}.")
                    self._warn(e)
                    continue
                if start < last_frame:
                    self._raise(RuntimeError("Label timecode contains overlap "
                                             f"in row {i}. Make sure csv is "
                                             "consectutive with no overlaps"))
                if i == error_count:
                    first_frame = start
                else:
                    self._check_input_path(file, last_file)
                    deletion_queue.append((last_frame, start))
                last_frame = end
                last_file = file
            try:
                first_frame
            except NameError:
                self._warn(f"{csv_path} contains no valid rows. Skipping to "
                           "next.")
                return None, []
            ffmpeg_args = self._generate_ffmpeg_args(input_path,
                                                     file,
                                                     first_frame,
                                                     end)
            return ffmpeg_args, deletion_queue

    def _clear_existing_frames(self):
        directory = os.path.dirname(self._output_placeholder)
        self._print(f"Clearing directory {directory}.")
        query = os.path.join(directory, "*.png")
        paths = glob.iglob(query)
        for path in paths:
            os.remove(path)

    def _execute_ffmpeg_command(self, ffmpeg_args):
        self._print(f'Executing ffmpeg command "{" ".join(ffmpeg_args)}"')
        ffmpeg = subprocess.Popen(ffmpeg_args)
        exit_code = ffmpeg.wait()
        if exit_code:
            self._warn(f"Exit code of {exit_code} ffmpeg command.")

    def _clear_unspecified_frames(self, deletion_queue):
        self._print("Removing unspecified frames.")
        for (start, end) in deletion_queue:
            for i in range(start, end):
                path = self._output_placeholder.format(i=i)
                os.remove(path)

    def extract_frames(self):
        """Creates the still frame datasets from the video clips according
        to the initialization arguments.
        """
        for csv_path in self._csvs:
            (ffmpeg_args,
             deletion_queue) = self._create_queues_from_csv(csv_path)
            self._clear_existing_frames()
            self._execute_ffmpeg_command(ffmpeg_args)
            self._clear_unspecified_frames(deletion_queue)


def main():
    # Change the following directories as needed.
    csvs = "."
    videos = "."
    output_dir = "."

    exporter = FfmpegCsvExporter(csvs, videos, output_dir)
    exporter.extract_frames()


if __name__ == "__main__":
    main()
